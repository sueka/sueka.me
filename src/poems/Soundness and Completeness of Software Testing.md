---
title: ソフトウェアテストの健全性と完全性
title_rubied: 'ソフトウェアテストの<ruby>健<rt>けん</rt>全<rt>ぜん</rt>性<rt>せい</ruby>と<ruby>完<rt>くゎん</rt>全<rt>ぜん</rt>性<rt>せい</ruby>'
date: 2021-10-24
lastmod: 2021-12-29
---

製品にバグがあれば必ず失敗するテストを健全なテスト、バグが無ければ必ず通過するテストを完全なテストと言ふ。例へば、

``` ts
function testF1() {
  throw new Error()
}
```

は健全なテスト、

``` ts
function testF2() {
}
```

は完全なテストである。

---

テストは、形式的に言へば、製品の<i>仕様上妥当な</i>入出力が<i>実際に妥当である</i>ことを証明する手続きである。例へば、恒等関数の<i>仕様上妥当な</i>入出力は

- (0, 0)
- (1, 1)

などであり、これらが<i>実際に妥当である</i>ことは

``` ts
import assert from 'assert'

interface IdentityFunction {
  (x: number): number
}

function testIdentity1(sut: IdentityFunction) {
  assert(sut(0) === 0)
  assert(sut(1) === 1)
}
```

といふふうにして証明できる。

`testIdentity1` は、

``` ts
function identity(x: number) {
  return x
}

testIdentity1(identity) // will be passed
```

のやうに製品にバグが無ければ通過するので完全だが、

``` ts
function wrongIdentity(x: number) {
  if (x === 1 / 2) return 1 / 3

  return x
}

testIdentity1(wrongIdentity) // will be passed
```

のやうにバグがあっても通過することがあるので健全ではない。

---

健全なテストは、

- 全ての<i>仕様上妥当な</i>入出力が<i>実際に妥当である</i>ことを証明するか、さもなくば
- 失敗する。

`identity` のやうな小さな関数であっても、全ての<i>仕様上妥当な</i>入出力が<i>実際に妥当である</i>ことを証明するには、家庭用 PC で数百万年から数億年、スーパーコンピューターでも数分から数時間を要するので、普通のソフトウェアのために健全なテストが書かれることはほゞ無い。

---

完全なテストは、

- ある<i>仕様上妥当</i>な入出力が<i>実際には妥当でない</i>ことを証明するか、さもなくば
- 通過する。

健全なテストがバグが無いことを証明しなければ通過できないのに対して、完全なテストは何もせずに通過させてもよいので、内容が貧弱になりやすい。テスト対象をうまくモデル化したり、テストカバレッジを計測したりして回避しよう。

なほ、CI で使ふテストは完全でなければならない。

*[CI]: Continuous Integration

---

ところで、テストカバレッジは、C0（文網羅率）でさへ 100 % を目指すべきではないと言はれてゐる。その理由の[1]{.upright}つは、実行結果をそのまゝ捨てられるといふことである。例へば、

``` ts
function testIdentity2(sut: IdentityFunction) {
  sut(1 / 2)
  assert(sut(0) === 0)
}
```

は、`wrongIdentity` を文網羅してゐるが、`wrongIdentity` を通過させてしまふ。勿論、アサーションされてゐない実行からはカバレッジを取らないやうなフレームワークもあると思ふが、そのやうなフレームワークは複雑だし、さうまでしなくても、この誤謬は `sut(1 / 2)` をアサーションするだけで回避できる。

---

入出力が非常に小さな製品なら健全なテストを書くこともできる。たゞし、他の多くのテストは完全なので、その場合、健全かつ完全なテストを書くべきだらう[^1]。

[^1]: 健全でなく完全なテストと完全でなく健全なテストを混在させたテストスイートは健全でも完全でもないため。

健全かつ完全なテストは、

- 全ての<i>仕様上妥当な</i>入出力が<i>実際に妥当である</i>ことを証明する。

例へば、否定論理積の健全かつ完全なテストは

``` ts
interface NandFunction {
  (a: boolean, b: boolean): boolean
}

function testNand1(sut: NandFunction) {
  assert(sut(false, false) === true)
  assert(sut(false, true) === true)
  assert(sut(true, false) === true)
  assert(sut(true, true) === false)
}
```

と書ける。

---

健全なテストが構成できるといふことは、その製品自体を健全に（[製品にバグがあれば必ず実行が事前に中止されるやうに]{.warichu}）構成できるといふことでもある。これを実現するには健全なテストを事前条件にすればよい。たゞし、オーバーヘッドになるので、普通は製品版をビルドする時に削除する。

逆に言へば、もし製品をこのやうに構成できない（[製品にバグが無いことを保証できない]{.warichu}）なら、その種類のバグはテストで炙り出せないといふことでもある。これはいかにも不健全なので、製品は健全なテストが書けるやうに書きたい。

---

直接的な入出力[^2]だけでは仕様を表現できない製品もある。さういふ製品の仕様は、副作用を入出力の一種と見做すと、大抵うまく表現できる。

[^2]: 関数なら引数と返り値、REST API なら本文。

副作用とは、関数が行ふ、値の返却以外の全てのことである。

- 処理系の環境を変更する
- 例外を投げる
- 処理系を停止させる
- 入力を読み取る、または出力する
  - 標準入出力
  - ファイル IO
  - イベントハンドリングとレンダリング（ウェブ）
- その関数が停止しない

といった作用がこれに当たるが、これで全部ではないと思ふ。

このうち、例外を投げること、処理系を停止させること、関数が停止しないことは、出力に含めるだけでテストできる。製品を実行する前にすでに例外が投げられてゐたり、処理系が停止してゐたり、関数が停止してゐなかったりといふ状況はありえない[^3][^4]。

[^3]: すでに関数が停止してゐないとはどういふことか……
[^4]: たゞし、例外が投げられたことや処理系が停止したこと、関数が停止しないことを検出するには少し工夫が要る。`testIdentity1` みたいな単なる関数ではうまくいかない。

しかし、処理系の環境を変更することゝ入出力は、その副作用が冪等でなければ、入力と出力を比較しなければ仕様を表現できない。

---

例外を投げるプログラムはなるべく書かない。例外は参照透過性を破壊する。可能ならモナドを使ふ。やむをえず例外を使ふ場合も例外安全に書く。強い保証[^5]があれば、キャッチした例外を（必要ならアサーションした上で）握り潰して、そのまゝ次のアサーションを行ふことができるので、テストが簡単になる。強い保証が無い場合、環境[^6]を作り直さなければならないことがある。

[^5]: <q><em class="sans-serif">強い保証</em>。例外によってある操作が終了した場合に、プログラムの状態が変更されていないこと。これは常にコミットロールバックを意味し、ある操作が失敗してもコンテナへの参照やイテレータが無効化されないことを含んでいる。</q>、『<cite>Exceptional C++</cite>』（ピアソン・エデュケーション、[2000]{.upright}年）[42]{.tate-chu-yoko}ページ。
[^6]: <i lang="en">xUnit Patterns</i> の [test fixture]{lang=en} に近い。

---

停止しないプログラムは書かない。プログラムが有限時間で停止するかどうかは、`while (true)` みたいな単なる無限ループなら構文解析すれば調べられるが、停止性問題を一般に解くことはできない[^7]ので、停止しないプログラムはテスト不可能と考へた方が良い。判定できないものをどうやって書かないやうにするのかといふと、

[^7]: 任意のプログラムと入力に対して、そのプログラムがその入力で実行されたとき、その実行が終了するかどうかを常に正しく判定するアルゴリズムは存在しないといふことが証明されてゐる。

1. ソフトウェアレビューによって検出する[^8]か、
2. 無限ループの書けない[^9]言語を使ふ。

[^8]: 保証はできない。
[^9]: 少なくともチューリング完全ではない。

有限時間で停止するかどうかは調べられないが、確実に停止しないと言ふことはできる場合がある。再帰関数が全く同じ引数で実行されたときや、ループ中に処理系の環境[^10]が全く同じ状態になったときなどがこれに当たる。

[^10]: 変数の集合と言ってもよいし、変数名の集合から値の集合への関数と言ってもよいと思ふ。

---

健全性と完全性は、種々のテストで、そのテストの良さの指標として使はれてゐる。例へば、

- 型理論では、言語が健全な（[型が付けられるならば型エラーが起こらない]{.warichu}）型システムを備へてゐることを型安全と言ふ。
- 臨床検査では、真陽性の人の個数を実際に感染等してゐる人の個数で割ったものを感度と言ふ。検査が健全（[偽陰性を犯さない]{.warichu}）なら感度は[1]{.upright}である。
- 統計的仮説検定では、偽陽性には第[1]{.upright}種の過誤、偽陰性には第[2]{.upright}種の過誤といふ別名がある。第[2]{.upright}種の過誤を犯さない確率を対立仮説における検出力と言ふ。
- 刑事裁判には、「疑はしきは被告人の利益に」や「無罪の推定」などの冤罪を回避するための原則がある。
